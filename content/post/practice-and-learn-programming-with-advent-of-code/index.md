---
date: 2025-01-26T15:30:00Z
draft: true
title: I play Advent of Code, and you should too!
description: |-
  For the past 5 years, I've been playing Advent of Code.
  Every year Eric Wastl creates 25 puzzles with an associated story about Santa.
  Each puzzle has two parts and can be solved in any programming language your prefer.
  If you get all the answers right, collecting all 50 stars, you can consider yourself one of a very select group of people!
featured_image: /images/featured-advent-of-code.jpg
cover_dimming_class: bg-black-60
toc: true
tags:
  - Algorithms
  - Learning
  - Python
  - C#
  - Ruby
  - JavaScript
---

One of the hardest parts of learning a language's fundamentals is having enough meaningful problems to solve.
"Hello World!" is all well and good, but when do you ever have to use that code in an application you're building?
That's where Advent of Code comes in for me.
Here I'm going to discuss what Advent of Code is, how to get started on Advent of Code, a brief look at some of my favourite puzzle types on there, and which languages I've attempted to use each year.

## What is Advent of Code?

[Advent of Code](https://adventofcode.com) is a website and annual event created and maintained by [Eric Wastl](https://hachyderm.io/@ericwastl).
Like it sounds, it runs throughout December, up to and including Christmas Day on the 25th.
Absolutely anyone can take part.
Each day, a new puzzle is made available at exactly 05:00 UTC (midnight on the US East coast).

In each puzzle, there is a part 1 and a part 2.
Usually both parts have the same input, but part 2 is a development on part 1 that makes it a lot harder to solve with a naive solution.
Often part 1 tempts you to apply a simple solution, and you probably should!
However, part 2 will need you to find efficiencies and short cuts to your approach.
Trimming down the problem space becomes essential.

The puzzles generally increase in complexity over the event, but complexity is very much linked to your skill set.
There is a global leaderboard for the fastest solvers, but it is really very competitive and not worth worrying about while you're trying to learn new things.

## How to get started

This is the easy bit!
Visiting the site, you'll see there is a simple design and a menu at the top.
If you choose to Log In, you'll have several options for how to identify yourself, but I choose to use my GitHub account as I feel it ties my identity to the place where I store my solutions.
Once you're logged in, you can choose the Events menu and select which year you want to solve puzzles from.
It doesn't really matter which year you choose unless you're wanting to solve puzzles in December, of course!

Once you've selected a year, you'll face a list of numbered puzzles.
It's probably best to solve them in day order since, in some years, solutions from one day are relevant to those in later days.
Plus, of course, earlier days are easier to solve which is a good way to escalate your understanding of the language you're working in.

Take some time to read the puzzle introduction story.
They are very well written and often contain a lot of humour you might enjoy.
The text will explain the problem and give an example of how you would solve a simple input.
The real input is then accessible via a link at the bottom of the text.
You should take this and start writing some code to apply your solution to it.

Once you think you have the correct answer, paste it into the website and check if it's correct.
One of a few things will happen here:

- You've got the right answer.
  Well done!
  Now check out part 2 and try to solve that as well.
- You got the wrong answer.
  - If this is your first attempt, or one of the first 5 or so attempts, you'll be told if your answer is too low or too high.
    You'll also be blocked from trying another answer for a minute or two, to stop people spam guessing.
  - If you've had quite a few attempts at this point, you'll not be given any more clues about whether you need to go higher or lower and the wait time to try another answer could be quite a few minutes between attempts.

If you find yourself struggling, it's usually a good idea to quickly switch to the example in the story.
This usually lets you iterate quickly on a solution and you know if you have the right answer because it's shown in the story text (usually, but not always).
Just remember to switch to the real input before making a new attempt!

## Some of my favourite types of puzzles

The puzzles in Advent of Code can be quite varied, but there are certain puzzles that I particularly enjoy.
Here are three examples along with approaches I tend to use.

### Build a computer using code

Text

### Find the shortest path

Text

### Parsing text input for patterns

Text

## Choice of language

Below is a list of the languages I've used in past years and what I thought of them for this sort of challenge.
It's worth noting that I have a tendency to go for scripting languages over more formally compiled languages as I find them to be more dynamic when working with the sorts of puzzles you typically get from Advent of Code.

| Year | Stars | Languages |
| ---- | ----: | --------- |
| [2019](https://github.com/sdjmchattie/AdventOfCode2019) | 27 | Python |
| [2020](https://github.com/sdjmchattie/AdventOfCode2020) | 48 | Ruby |
| [2021](https://github.com/sdjmchattie/AdventOfCode2021) | 38 | JavaScript |
| [2022](https://github.com/sdjmchattie/AdventOfCode2022) | 50 | Python |
| [2023](https://github.com/sdjmchattie/AdventOfCode2023) | 50 | C# and [Rust](https://github.com/sdjmchattie/AdventOfCode2023Rust) |
| [2024](https://github.com/sdjmchattie/AdventOfCode2024) | 50 | Ruby |

In 2020, there was just one puzzle that got the better of me.
Because the second star on day 25 expects you to have all 49 other stars, it leaves me two stars short of completion!
I should go back to the unsolved puzzle and see if I can do it with my new skills.

In 2023 I attempted the puzzles twice but my initial attempt was in C#.
I decided if I wanted to try some Rust, I should apply it to a year I'd already solved as I knew Rust was going to challenge me!

### Python

Text

### C Sharp (C#)

Text

### Ruby

Text

### JavaScript

Text

### Rust

Text
